# Генерация Валидных Скобочных Последовательностей

Этот модуль содержит алгоритмы для генерации всех возможных валидных скобочных последовательностей для заданного количества пар скобок.

## Проблема

Дано число `n`, требуется сгенерировать все возможные валидные комбинации из `n` пар скобок `()`.

**Примеры:**
- n=1: `["()"]`
- n=2: `["(())", "()()"]`  
- n=3: `["((()))", "(()())", "(())()", "()(())", "()()()"]`

## Алгоритмы

### 1. Базовый алгоритм (Backtracking)

```python
def generate_basic(n: int) -> List[str]:
```

**Принцип работы:**
1. Начинаем с пустой строки
2. На каждом шаге можем добавить `(` или `)` при соблюдении условий:
   - `(` можно добавить, если количество открывающих < n
   - `)` можно добавить, если количество закрывающих < открывающих
3. Когда длина строки = 2*n, сохраняем результат
4. Откатываемся назад (backtrack) для поиска других вариантов

**Временная сложность:** O(4^n / √n) - каталанские числа
**Пространственная сложность:** O(4^n / √n)

### 2. Оптимизированный алгоритм

```python
def generate_optimized(n: int) -> List[str]:
```

**Улучшения:**
- Использует строку вместо списка для лучшей производительности
- Меньше операций добавления/удаления элементов
- Более эффективное использование памяти

### 3. Итеративный алгоритм

```python
def generate_iterative(n: int) -> List[str]:
```

**Преимущества:**
- Избегает рекурсии
- Использует стек для отслеживания состояния
- Подходит для больших значений n (избегает переполнения стека)

## Каталанские числа

Количество валидных скобочных последовательностей для n пар равно n-му каталанскому числу.

**Формула:** C(n) = (2n)! / ((n+1)! * n!)

**Первые значения:**
- C(0) = 1
- C(1) = 1  
- C(2) = 2
- C(3) = 5
- C(4) = 14
- C(5) = 42

## Пошаговое объяснение (n=3)

```
Начальное состояние: "" (0 открывающих, 0 закрывающих)

Шаг 1: Добавляем "(" → "(" (1, 0)
  Шаг 2: Добавляем "(" → "((" (2, 0)
    Шаг 3: Добавляем "(" → "(((" (3, 0)
      Шаг 4: Добавляем ")" → "((()" (3, 1)
        Шаг 5: Добавляем ")" → "((())" (3, 2)
          Шаг 6: Добавляем ")" → "((()))" (3, 3) ✓ ГОТОВО
    Шаг 3: Добавляем ")" → "(()" (2, 1)
      Шаг 4: Добавляем "(" → "(()(" (3, 1)
        Шаг 5: Добавляем ")" → "(()())" (3, 2)
          Шаг 6: Добавляем ")" → "(()())" (3, 3) ✓ ГОТОВО
      Шаг 4: Добавляем ")" → "(())" (2, 2)
        Шаг 5: Добавляем "(" → "(())(" (3, 2)
          Шаг 6: Добавляем ")" → "(())()" (3, 3) ✓ ГОТОВО
  Шаг 2: Добавляем ")" → "()" (1, 1)
    Шаг 3: Добавляем "(" → "()(" (2, 1)
      Шаг 4: Добавляем "(" → "()((" (3, 1)
        Шаг 5: Добавляем ")" → "()(()" (3, 2)
          Шаг 6: Добавляем ")" → "()(())" (3, 3) ✓ ГОТОВО
      Шаг 4: Добавляем ")" → "()()" (2, 2)
        Шаг 5: Добавляем "(" → "()()(" (3, 2)
          Шаг 6: Добавляем ")" → "()()()" (3, 3) ✓ ГОТОВО

Результат: ["((()))", "(()())", "(())()", "()(())", "()()()"]
```

## Использование

```python
from parentheses_generator import generate_basic, generate_optimized, generate_iterative

# Базовый алгоритм
sequences = generate_basic(3)
print(sequences)  # ['((()))', '(()())', '(())()', '()(())', '()()()']

# Оптимизированный алгоритм
sequences = generate_optimized(3)

# Итеративный алгоритм  
sequences = generate_iterative(3)

# Подсчет количества без генерации
count = count_sequences(3)  # 5
```

## Тестирование

```bash
# Активировать виртуальное окружение
source .venv/bin/activate

# Запустить тесты
pytest test_parentheses_generator.py -v
```

## Бенчмарк

```python
from parentheses_generator import benchmark_algorithms

# Сравнение производительности
results = benchmark_algorithms(4, 3)
print(results)
```

## Применения

1. **Комбинаторика** - подсчет способов расстановки скобок
2. **Парсинг** - генерация всех возможных синтаксических деревьев
3. **Оптимизация** - поиск оптимальных структур данных
4. **Интервью** - популярная задача на алгоритмы

## Ограничения

- Временная сложность экспоненциальная
- Для n > 15 алгоритм становится очень медленным
- Требует много памяти для больших значений n

## Альтернативные подходы

1. **Динамическое программирование** - для подсчета без генерации
2. **Генерация по образцу** - использование известных паттернов
3. **Ленивая генерация** - генерация по требованию
4. **Параллельная обработка** - использование многопоточности
